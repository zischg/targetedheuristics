#***************************************************************
#script for plotting flood vulnerability functions including targeted heuristics method
#Andreas Paul Zischg, 09.11.2019
#***************************************************************
import math
import numpy
import pandas as pd
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt


#**************************************************************************
#functions block
#**************************************************************************
def definebuildingcategory(G_KATS_NWG,G_BAUP, buildingvalue):
    # buildingvalue in Swiss Francs
    #catlist=["EA", "EN", "MA", "MN", "GG", "GK", "SH", "SS"]
    if G_BAUP>8018 and G_KATS_NWG==1021:
        buildingcategory="EN"#detached house new
    elif G_BAUP<=8018 and G_KATS_NWG==1021:
        buildingcategory="EA"#detached house old
    elif G_BAUP>8018 and G_KATS_NWG in [1025,2046]:
        buildingcategory="MN"#apartment building new
    elif G_BAUP<=8018 and G_KATS_NWG in [1025,2046]:
        buildingcategory="MA"#apartment building old
    else:
        if buildingvalue>850000:
            buildingcategory="GG"
        else:
            buildingcategory="GK"
    return buildingcategory
def vulnerabilityTotschnig(flowdepth):
    # vulnerability function (Totschnig et al. 2011)
    # Totschnig, R., Sedlacek, W., and Fuchs, S.: A quantitative vulnerability function for fluvial sediment transport
    # Nat Hazards, 58, 681-703, doi:10.1007/s11069-010-9623-5, 2011.
    # requires math
    dol = 0.0
    if float(flowdepth) >=0.0:
        u = (float(flowdepth)+1.442)/1.442-1
        v = math.pow(u, 2.233)
        w = -0.443*v
        x = 1-math.exp(w)
        if x >=0.0 and x <=1.0 :
            dol = x
        elif x>1.0:
            dol = 1.0
        elif x<0.0:
            dol = 0.0
    else:
        dol = 0.0
    if dol>1:
        dol=1
    elif dol<0:
        dol=0
    return dol
def vulnerabilityFuchs(magnitude):
    #Fuchs, S., Heiser, M., Schlögl, M., Zischg, A., Papathoma - Köhle, M., and Keiler, M.: Short communication: A model to predict flood loss in mountain areas,
    #Environ.Modell.Softw., doi:10.1016/j.envsoft.2019.03.026, 2019
    dol = 0.0
    if magnitude <= 0:
        dol = 0.0
    else:
        dol = (pow(math.e,-7.40+2.56*magnitude)+(pow(math.e,-3.27+1.67*magnitude)/(1+pow(math.e,-3.27+1.67*magnitude))))/(1+pow(math.e,-9.49*magnitude)+pow(math.e,-7.40+2.56*magnitude))
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def vulnerabilityPapathoma(magnitude):
    # vulnerability function (Papathoma)
    # Papathoma-Koehle, M., Zischg, A., Fuchs, S., Glade, T., and Keiler, M.:
    # Loss estimation for landslides in mountain areas - An integrated toolbox for vulnerability assessment
    # and damage documentation, Environmental Modelling & Software, 63, 156-169, doi:10.1016/j.envsoft.2014.10.003, 2015.
    # requires math
    dol = 0.0
    a=-1.671
    b=3.189
    c=1.746
    if magnitude <= 0:
        dol = 0.0
    else:
        dol = 1-pow(math.e,a*pow(((magnitude+b)/b-1),c))
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def vulnerabilityHydrotec(magnitude):
    # vulnerability function HYDROTEC (2001)
    # Apel, H., Aronica, G. T., Kreibich, H., Thieken, A. H. (2009): Flood risk
    # analyses - how detailed do we need to be?.- Natural Hazards, 49, 1, 79-98
    # DOI: 10.1007/s11069-008-9277-8
    # Squareroot function
    # requires math
    dol=0.0
    if magnitude <= 0:
        dol = 0.0
    else:
        dol = (27*math.sqrt(magnitude))/100
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def vulnerabilityKaltenrieder(flowdepth):
    # *******************************************************************************
    # Kaltenrieder Rahel (2017, Master thesis at GIUB):
    # "Physische Vulnerabilitaet von Gebaeuden gegenueber Hochwasserereignissen".
    # Model 1:
    # 1 explaining Variable (flow depth), Tab 24, p 54
    # Power 2 function#
    # *******************************************************************************
    dol=0.0
    if flowdepth <= 0:
        dol=0.0
    else:
        dol=math.pow((0.18846 + 0.17152*flowdepth),2)
    if dol > 1:
        dol = 1.0
    elif dol < 0:
        dol == 0.0
    return dol
def vulnerabilityJonkman(flowdepth, arr):
    # ***********************************************************************************************************************
    # Jonkman, S. N., Bockarjova, M., Kok, M., and Bernardini, P.: Integrated hydrodynamic and economic modelling of flood
    # damage in the Netherlands, Ecological Economics, 66, 77-90, https://doi.org/10.1016/j.ecolecon.2007.12.022, 2008.
    # ***********************************************************************************************************************
    # requires math
    dol=0.0
    depthmin=min(arr[:,0])
    depthmax=max(arr[:,0])
    dolmax=max(arr[:,1])
    x=arr[:,0]
    y=arr[:,1]
    f=interp1d(x, y)
    if flowdepth < depthmin:
        dol = 0.0
    elif flowdepth > depthmax:
        dol = dolmax
    else:
        dol = f(float(flowdepth))
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def vulnerabilityDutta(flowdepth, arr):
    # *******************************************************************************
    # Dushmanta Dutta, Srikantha Herathb, Katumi Musiakec. A mathematical model for
    # flood loss estimation. Journal of Hydrology, Volume 277 (1-2), 2003.
    # *******************************************************************************
    # requires math
    dol=0.0
    depthmin=min(arr[:,0])
    depthmax=max(arr[:,0])
    dolmax=max(arr[:,1])
    x=arr[:,0]
    y=arr[:,1]
    f=interp1d(x, y)
    if flowdepth < depthmin:
        dol = 0.0
    elif flowdepth > depthmax:
        dol = dolmax
    else:
        dol = f(float(flowdepth))
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def vulnerabilityKaragiorgos(flowdepth):
    # vulnerability function (Karagiorgos et al. 2016)
    # Karagiorgos, Konstantinos; Thaler, Thomas; Heiser, Micha; Huebl, Johannes; Fuchs, Sven (2016): Integrated flash flood vulnerability assessment. Insights from East Attica, Greece. In Journal of Hydrology 541, pp.553-562. DOI: 10.1016/j.jhydrol.2016.02.052.
    if float(flowdepth) >=0.0:
        u = (float(flowdepth)+1.76)/1.76-1
        v = math.pow(u, 0.283)
        w = -0.032*v
        x = 1-math.exp(w)
        if x >=0.0 and x <=1.0 :
            dol = x
        elif x>1.0:
            dol = 1.0
        elif x<0.0:
            dol = 0.0
    else:
        dol = 0.0
    if dol>1:
        dol=1
    elif dol<0:
        dol=0
    return dol
def vulnerabilityEconoMe(flowdepth, velocity, buildingcategory):
    # *******************************************************************************
    # Bruendl Michael (Ed.) 2009. Risikokonzept für Naturgefahren - Leitfaden.
    # Nationale Plattform für Naturgefahren PLANAT, Bern. 420 S.
    # s. Chapter 4 (Richtwerte EconoMe), p. 158
    # resid_units = 1: single-family house (default)
    # resid_units > 1: multi-family house
    # resid_units = 0: non-residential buildings
    # *******************************************************************************
    dol = 0.0
    vh = velocity * flowdepth
    if buildingcategory in ["EN","EA"]:#G_KATS_NWG = 1021
        #single family house
        if flowdepth > 0 and flowdepth < 0.5:
          dol = 0.02
        elif (flowdepth >= 0.5 and flowdepth < 2) or (vh >= 0.5 and vh < 2):
          dol = 0.2
        elif flowdepth >= 2 or vh >= 2:
          dol = 0.3
    elif buildingcategory in ["MN","MA"]:#G_KATS_NWG == 1025 or G_KATS_NWG == 2046
    # Einheitlicher Gebäudetyp Mehrfamilienhaus oder Ein/Mehrfamilienhaus gemischt
        if flowdepth > 0 and flowdepth < 0.5:
            dol = 0.006
        elif (flowdepth >= 0.5 and flowdepth < 2) or (vh >= 0.5 and vh < 2):
            dol = 0.15
        elif flowdepth >= 2 or vh >= 2:
            dol = 0.25
    else:
    # all other building types
        if flowdepth > 0 and flowdepth < 0.5:
          dol = 0.1
        elif (flowdepth >= 0.5 and flowdepth < 2) or (vh >= 0.5 and vh < 2):
          dol = 0.3
        elif flowdepth >= 2 or vh >= 2:
          dol = 0.4
    return dol
def mortalityJonkmanFastRise(magnitude):
    # mortality function Jonkman (2007) - dam breaks
    mue=1.46
    sigma=0.28
    if magnitude <= 0.0:
        dol = 0.0
    else:
        dol = (math.log(magnitude,math.e)-mue)/sigma
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def mortalityJonkmanSlowRise(magnitude):
    #mortality function Jonkman (2007) - slow rise
    mue=7.60
    sigma=2.75
    if magnitude <= 0.0:
        dol = 0.0
    else:
        dol = (math.log(magnitude,math.e)-mue)/sigma
    if dol>1:
        dol=1.0
    elif dol<0:
        dol=0.0
    return dol
def vulnerabilityMURL(flowdepth):
    if numpy.float(flowdepth) >=0.0 and numpy.float(flowdepth) <=5.0:
        x = 0.02*flowdepth
        if x >=0.0 and x <=1.0 :
            dol = x
        elif x>1.0:
            dol = 1.0
        elif x<0.0:
            dol = 0.0
    elif numpy.float(flowdepth) >=5.0:
        dol=0.10
    else:
        dol = 0.0
    if dol>1:
        dol=1
    elif dol<0:
        dol=0
    return dol
def vulnerabilityICPR(flowdepth):
    if numpy.float(flowdepth) >=0.0:
        x = (2*flowdepth*flowdepth+2*flowdepth)/100.0
        if x >=0.0 and x <=1.0 :
            dol = x
        elif x>1.0:
            dol = 1.0
        elif x<0.0:
            dol = 0.0
    else:
        dol = 0.0
    if dol>1:
        dol=1
    elif dol<0:
        dol=0
    return dol
def vulnerabilityTargetedHeuristics(magnitude, buildingcategory):
    dol=0.0
    if buildingcategory=="EA":
        #old detached house
        if magnitude>0.0 and magnitude <=0.25:
            dol = 0.008
        elif magnitude>0.25 and magnitude <=0.5:
            dol = 0.152
        elif magnitude>0.5 and magnitude <=1.0:
            dol = 0.366
        elif magnitude>1.0:
            dol = 0.464
    elif buildingcategory=="EN":
        #new detached house
        if magnitude>0.0 and magnitude <=0.25:
            dol = 0.148
        elif magnitude>0.25:
            dol = 0.319
    elif buildingcategory=="MA":
        #old apartment building
        if magnitude>0.0 and magnitude <=0.5:
            dol = 0.238
        elif magnitude>0.5 and magnitude <=0.75:
            dol = 0.320
        elif magnitude>0.75 and magnitude <=1.0:
            dol = 0.328
        elif magnitude>1.0:
            dol = 0.393
    elif buildingcategory=="MN":
        #new apartment building
        if magnitude>0.0 and magnitude <=0.25:
            dol = 0.083
        elif magnitude>0.25 and magnitude <=0.5:
            dol = 0.222
        elif magnitude>0.5 and magnitude <=0.75:
            dol = 0.233
        elif magnitude>0.75:
            dol = 0.363
    elif buildingcategory=="GG":
        #commercial property, large
        if magnitude>0.0 and magnitude <=1.0:
            dol = 0.041
        elif magnitude>1.0:
            dol = 0.070
    elif buildingcategory=="GK":
        #commercial property, small
        if magnitude>0.0 and magnitude <=0.25:
            dol = 0.088
        elif magnitude>0.25 and magnitude <=0.5:
            dol = 0.111
        elif magnitude>0.5 and magnitude <=0.75:
            dol = 0.139
        elif magnitude>0.75:
            dol = 0.194
    elif buildingcategory=="SH":
        #hotel
        if magnitude>0.0 and magnitude <=0.75:
            dol = 0.020
        if magnitude>0.75 and magnitude <=1.5:
            dol = 0.051
        elif magnitude>1.5:
            dol = 0.076
    else:
        # all others, same as GK
        if magnitude > 0.0 and magnitude <=0.25:
            dol = 0.088
        elif magnitude > 0.25 and magnitude <=0.5:
            dol = 0.111
        elif magnitude > 0.5 and magnitude <=0.75:
            dol = 0.139
        elif magnitude > 0.75:
            dol = 0.194
    return dol
def flowvelocity(flowdepth, slope, strickler):
    velocity=strickler*math.pow(flowdepth,(2.0/3.0))*math.pow(slope, 0.5)
    return velocity
#**************************************************************************
#end of functions block
#**************************************************************************

#**************************************************************************
#prepare x and y vectors for plotting the vulnerability functions
xlist=numpy.arange(0.0,5.1,0.05).tolist()
ytot=[]
for item in xlist:
    ytot.append(vulnerabilityTotschnig(item))
yfuchs=[]
for item in xlist:
    yfuchs.append(vulnerabilityFuchs(item))
ykar=[]
for item in xlist:
    ykar.append(vulnerabilityKaragiorgos(item))
ypap=[]
for item in xlist:
    ypap.append(vulnerabilityPapathoma(item))
yhyd=[]
for item in xlist:
    yhyd.append(vulnerabilityHydrotec(item))
ykal=[]
for item in xlist:
    ykal.append(vulnerabilityKaltenrieder(item))
yjon=[]
for item in xlist:
    yjon.append(vulnerabilityJonkman(item, jonkmanarr))
ydut=[]
for item in xlist:
    ydut.append(vulnerabilityDutta(item, duttaarr))
yecoEFH=[]
for item in xlist:
    yecoEFH.append(vulnerabilityEconoMe(item, 0, "EN"))
yecoMFH=[]
for item in xlist:
    yecoMFH.append(vulnerabilityEconoMe(item, 0, "MN"))
yecorest=[]
for item in xlist:
    yecorest.append(vulnerabilityEconoMe(item, 0, "GG"))
yheurEN=[]
for item in xlist:
    yheurEN.append(vulnerabilityTargetedHeuristics(item, "EN"))
yheurEA=[]
for item in xlist:
    yheurEA.append(vulnerabilityTargetedHeuristics(item, "EA"))
yheurMN=[]
for item in xlist:
    yheurMN.append(vulnerabilityTargetedHeuristics(item, "MN"))
yheurMA=[]
for item in xlist:
    yheurMA.append(vulnerabilityTargetedHeuristics(item, "MA"))
yheurGG=[]
for item in xlist:
    yheurGG.append(vulnerabilityTargetedHeuristics(item, "GG"))
yheurGK=[]
for item in xlist:
    yheurGK.append(vulnerabilityTargetedHeuristics(item, "GK"))


#plot combined figure vulnerability functions
fig, axes =plt.subplots(nrows=2, ncols=2, figsize = (10,10), sharey=True, sharex=True)
xlabels=[0,1,2,3,4]
x = numpy.arange(len(xlabels))
#targeted heuristics
axes[0][0].plot(xlist,yheurEN,label="new detached building", color="blue")
axes[0][0].plot(xlist,yheurEA,label="old detached building", color="blue", dashes=[6,2])
axes[0][0].plot(xlist,yheurMN,label="new apartment building", color="red")
axes[0][0].plot(xlist,yheurMA,label="old apartment building", color="red", dashes=[6,2])
axes[0][0].plot(xlist,yheurGG,label="commercial building, high value", color="grey")
axes[0][0].plot(xlist,yheurGK,label="commercial building", color="grey", dashes=[6,2])
axes[0][0].set_title('a) targeted heuristics')
#axes[0][0].set_xlabel("flow depth [m]", color="black")
axes[0][0].set_xticks(x)
axes[0][0].set_xticklabels(xlabels)
axes[0][0].legend(loc="upper left", frameon=False)
axes[0][0].set_ylim((0,1))
axes[0][0].set_xlim((0,4))
axes[0][0].set_ylabel("degree of damage [-]")
#multi-model enesemble
axes[0][1].plot(xlist,ydut,label="Dutta et al.")
axes[0][1].plot(xlist,yjon,label="Jonkman et al.")
axes[0][1].plot(xlist,ykar,label="Karagiorgos et al.")
axes[0][1].plot(xlist,yfuchs,label="Fuchs et al.")
axes[0][1].set_title('b) multi-model ensemble')
#axes[0][0].set_xlabel("flow depth [m]", color="black")
axes[0][1].set_xticks(x)
axes[0][1].set_xticklabels(xlabels)
axes[0][1].legend(loc="upper left", frameon=False)
axes[0][1].set_ylim((0,1))
axes[0][1].set_xlim((0,4))
#Kaltenrieder
axes[1][0].plot(xlist,ykal)
axes[1][0].set_title('c) regional calibration')
#axes[0][1].set_ylabel("degree of loss [-]")
#axes[0][1].set_xlabel("flow depth [m]", color="black")
axes[1][0].set_xticks(x)
axes[1][0].set_xticklabels(xlabels)
axes[1][0].set_ylim((0,1))
axes[1][0].set_xlim((0,4))
axes[1][0].set_ylabel("degree of damage [-]")
axes[1][0].set_xticks(x)
axes[1][0].set_xticklabels(xlabels)
axes[1][0].set_xlabel("flow depth [m]", color="black")
#econome
axes[1][1].plot(xlist, yecoEFH, label="detached building", color="blue")
axes[1][1].plot(xlist, yecoMFH, label="apartment building", color="red")
axes[1][1].plot(xlist, yecorest, label="commercial building", color="grey")
axes[1][1].set_title('d) econoMe')
axes[1][1].set_xlabel("flow depth [m]", color="black")
axes[1][1].set_xticks(x)
axes[1][1].set_xticklabels(xlabels)
axes[1][1].legend(loc="upper left", frameon=False)
axes[1][1].set_ylim((0,1))
axes[1][1].set_xlim((0,4))
#axes[1][1].set_ylabel("degree of damage [-]")
axes[1][1].set_xlabel("flow depth [m]", color="black")
axes[1][1].set_xticks(x)
axes[1][1].set_xticklabels(xlabels)
axes[1][1].set_ylim((0,1))
axes[1][1].set_xlim((0,4))
#tight layout
fig.subplots_adjust(hspace=0.4)
fig.tight_layout()
plt.show()
